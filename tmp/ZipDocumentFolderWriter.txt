package kosmos.maxthreshold.component.common;

import kosmos.document.Document;
import kosmos.util.IOUtils;
import org.apache.log4j.Logger;

import java.io.*;
import java.nio.channels.FileLock;
import java.sql.Blob;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

public class ZipDocumentFolderWriter {
    private static Logger logger = Logger.getLogger(ZipDocumentFolderWriter.class);
    private File directory;
    private Integer documentsPerZip;

    public ZipDocumentFolderWriter(File directory, Integer documentsPerZip) {
        this.directory = directory;
        this.documentsPerZip = documentsPerZip;
    }

    private byte[] getData(final Document document) {
        Blob data = document.getData();
        try {
            if (data == null) {
                logger.error("Blob of document is null with ID: " + document.getID() + " cannot save document.");
                return null;
            } else {
                return IOUtils.getBytes(data.getBinaryStream());
            }
        } catch (Exception e) {
            logger.error("Could not get data of document with ID: " + document.getID(), e);
            return null;
        }
    }

    private boolean generateDocument(final ZipOutputStream zos, final Document document) throws IOException {
        byte[] documentData = getData(document);
        if (documentData != null) {
            ZipEntry entry = new ZipEntry(document.getName() + ".pdf");
            zos.putNextEntry(entry);
            logger.info("Add document file to archive: " + entry.getName());
            zos.write(documentData);
            zos.closeEntry();
            return true;
        } else {
            return false;
        }
    }

    private void loadExistedZipFile(final ZipOutputStream zos, final File existedZipFile, final String skipZipEntryName) throws IOException {
        File tempZipFile = File.createTempFile(existedZipFile.getName(), ".tmp");
        tempZipFile.delete();
        existedZipFile.renameTo(tempZipFile);
        ZipInputStream zis = null;

        try {
            zis = new ZipInputStream(new FileInputStream(tempZipFile));
            ZipEntry existedEntry = zis.getNextEntry();
            while (existedEntry != null) {
                String existedEntryName = existedEntry.getName();
                if (existedEntryName.equalsIgnoreCase(skipZipEntryName)) {
                    existedEntry = zis.getNextEntry();
                    continue;
                }
                zos.putNextEntry(new ZipEntry(existedEntryName));
                org.apache.commons.io.IOUtils.copy(zis, zos);
                existedEntry = zis.getNextEntry();
            }
        } finally {
            org.apache.commons.io.IOUtils.closeQuietly(zis);
        }
    }

    private File getLastModifiedZipFile() throws IOException {
        File[] files = directory.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.toLowerCase().endsWith(".zip");
            }
        });
        if (files.length == 0) {
            return null;
        }

        Arrays.sort(files, new Comparator<File>() {
            @Override
            public int compare(File f1, File f2) {
                return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified());
            }
        });

        return files[files.length - 1];
    }

    private int getDocumentAmountInZip(final File zipFile) throws IOException {
        int counter = 0;
        Enumeration zipEntries = new ZipFile(zipFile).entries();

        while (zipEntries.hasMoreElements()) {
            counter++;
            zipEntries.nextElement();
        }

        return counter;
    }

    public synchronized boolean write(final Document document) {
        FileLock fileLock = null;
        ZipOutputStream zos = null;
        File existedZipFile;
        File processingZipFile;

        try {
            existedZipFile = getLastModifiedZipFile();

            if (existedZipFile == null) {
                processingZipFile = new File(directory.getParent() + File.separator + "1.zip");
            } else {
                processingZipFile = existedZipFile;
                int documentAmountInZip = getDocumentAmountInZip(processingZipFile);
                String processingZipFileName = processingZipFile.getName();
                int zipAmountCounter = Integer.parseInt(processingZipFileName.substring(0, processingZipFileName.lastIndexOf(".")));

                if (documentAmountInZip == documentsPerZip) {
                    zipAmountCounter++;
                    processingZipFile = new File(directory.getParent() + File.separator + zipAmountCounter + ".zip");
                }
            }

            if (processingZipFile.exists()) {
                FileOutputStream fos = new FileOutputStream(processingZipFile);
                fileLock = fos.getChannel().tryLock();
                loadExistedZipFile(zos, processingZipFile, document.getName() + ".pdf");
            } else {
                zos = new ZipOutputStream(new FileOutputStream(processingZipFile));
            }

            return generateDocument(zos, document);

        } catch (Exception ex) {

        } finally {
            if (fileLock != null) {
                try {
                    fileLock.release();
                } catch (IOException e) {
                }
            }
            org.apache.commons.io.IOUtils.closeQuietly(zos);
        }
        return false;
    }
}
